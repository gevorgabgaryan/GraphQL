https://www.apollographql.com/docs/apollo-server
1. npm i @apollo/server graphql

resolvers/index.js

const resolvers = {
    Query: {
      hello: () => 'Hello world',
    },
  };

export default resolvers;



schemas/index.js


import { buildSchema } from "graphql";

const schemas = buildSchema(`
    type Query {
        hello: String
    }
`)

export default schemas;


API/index.js

import { ApolloServer } from '@apollo/server';
import { expressMiddleware } from '@apollo/server/express4';
import { ApolloServerPluginDrainHttpServer } from '@apollo/server/plugin/drainHttpServer'
import schemas from '../schemas';
import resolvers from '../resolvers';

// Set up Apollo Server
const server = new ApolloServer({
  typeDefs: schemas,
  resolvers,
  plugins: [ApolloServerPluginDrainHttpServer({ httpServer })],
});
await server.start();

app.use(
  expressMiddleware(server),
);

index.js

http://localhost:8000/graphql

query {
  hello
}


2. Get users
resolvers/index.js

import UserModel from "../models/UserModel";

const resolvers = {
    Query: {
      users: async () => {
         try{
            return await UserModel.find();
         } catch(e) {
            throw e;
         }
      },
    },
  };

export default resolvers;


schemas/index.js

import { buildSchema } from "graphql";

const schemas = buildSchema(`
    type User {
        id: String!
        firstName: String!
        lastName: String!
        role: String!
        status: String!
        email: String!
    }

    type Query {
        users: [User]
    }
`)

export default schemas;


query {
  users {
    id
    firstName
  }
}


http://localhost:8000/graphql

query {
  users {
    id
    firstName
  }
}

frontend

query user($userId: ID) {
  user(id: $userId) {
    email
  }
}

{
  "userId": "660f9bafb11e2b0393819221"
}


3. get user

resolvers Query

    user: async (_, {id}) => {
         try{
            return await UserModel.findOne({_id: id});
         } catch(e) {
            throw e;
         }
      },

 schemas Query

 user(id: ID): User


4. Register

resolvers

    Mutation : {
      regUser: async (_, {input}) => {
          try {
              const user = await UserModel.findOne({email: input.email});
              if (user) throw new Error('User already exists');
              const newUser = await UserModel.create({
                  firstName: input.firstName,
                  lastName: input.lastName,
                  email: input.email,
                  role: 'user',
                  status: "active",
                  password: input.password
              })

              newUser.id = newUser._id;
              return newUser;
          } catch (error) {
              throw error;
          }
      },
   }

schema

 input UserInput {
      id: ID
      firstName: String
      lastName: String
      role: String
      status: String
      email: String!
      password: String!
  }


 type Mutation {
    regUser(input: UserInput!): User!
 }

 Frontend Query

mutation RegUser($input: UserInput!) {
  regUser(input: $input) {
    id
    firstName
    lastName
    role
    status
    email
  }
}

{
  "input": {
    "email": "gevorg@gmail.com",
    "password": "Ga123456"
  }
}


4. Login, Edit, Delete

resolvers

import jwt from 'jsonwebtoken'
import config from "../config";

    loginUser: async (_, { email, password }) => {
         const user = await UserModel.findOne({ email });
         if (!user) throw new Error('User not found');
         const isValid = await user.comparePassword(password);
         if (!isValid) throw new Error('Invalid password');
         const token = jwt.sign({ userId: user.id, role: user.role }, config.JWTSecret, { expiresIn: '1d' });
         return { token, user };
      },

      editUser: async (_, args, context) => {
         if (!context.user || context.user.userId !== args.id) throw new Error('Not authorized or invalid user');
         const updatedUser = await UserModel.findByIdAndUpdate(args.id, args, { new: true });
         return updatedUser;
      },

      deleteUser: async (_, { id }, context) => {
         if (!context.user || context.user.role !== 'ADMIN') throw new Error('Not authorized or not an admin');
         await UserModel.findByIdAndDelete(id);
         return 'User successfully deleted';
      },


schemas

    type Mutation {
        regUser(email: String!, password: String!, firstName: String, lastName: String): User!
        loginUser(email: String!, password: String!): AuthPayload!
        editUser(id: String!, firstName: String, lastName: String, email: String): User
        deleteUser(id: String!): String
    }

    type AuthPayload {
        token: String!
        user: User!
    }



    query


   type Mutation {
        regUser(email: String!, password: String!, firstName: String, lastName: String): User!
        loginUser(email: String!, password: String!): AuthPayload!
        editUser(id: String!, firstName: String, lastName: String, email: String): User
        deleteUser(id: String!): String
    }

    type AuthPayload {
        token: String!
        user: User!
    }

{
  "email": "g@gmail.com",
  "password": "Ga123456",

}